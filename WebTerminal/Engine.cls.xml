<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="WebTerminal.Engine">
<Super>%CSP.WebSocket,%Library.Routine,%CSP.REST</Super>
<TimeCreated>63011,62967.655821</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Parameter AuthKey As %String; HOW TO CHANGE PARAMETER AT RUNTIME? ELSE CLASS WILL USE GLOBAL.

]]></Content>
</UDLText>

<Property name="WebSocketID">
<Description>
The unique identity of this WebSocket.</Description>
<Type>%String</Type>
</Property>

<Property name="SharedConnection">
<Description><![CDATA[
This property determines whether the communication between the client and WebSocket server should be over a dedicated Gateway
conection or over a pool of shared connections.  It may be set to one of the following:
<br><ul>
<li><b>SharedConnection=0</b> - The WebSocket server communicates with the client via a dedicated Gateway connection. In this mode of operation the hosting connection is effectively 'private' to the application session.</li>
<li><b>SharedConnection=1</b> - The WebSocket server communicates asynchronously with the client via a fixed number of shared Gateway connections.</li>
</ul>]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SessionId">
<Description>
The CSP Session ID from which this WebSocket was created.</Description>
<Type>%String</Type>
</Property>

<Property name="GWClientAddress">
<Description><![CDATA[
The address through which a WebSocket operating asynchronously (<property>SharedConnection=1</property>) can communicate with the hosting CSP Gateway.]]></Description>
<Type>%String</Type>
</Property>

<Property name="lastClientId">
<Description>
Last joined client id</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="AUTHORIZATION">
<Description>
Authorization identifier</Description>
<Type>%Char</Type>
<InitialExpression>"?"</InitialExpression>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="MESSAGE">
<Description>
Message identifier</Description>
<Type>%Char</Type>
<InitialExpression><![CDATA[">"]]></InitialExpression>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="CHANGENAMESPACE">
<Description>
Zone change identifier</Description>
<Type>%Char</Type>
<InitialExpression>"_"</InitialExpression>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="CurrentNamespace">
<Type>%String</Type>
<InitialExpression>"USER"</InitialExpression>
</Property>

<Method name="OnPreServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="OnPostServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ 	quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateAuthKey">
<Description>
Generating new authorization key</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set temp = ""
	set length = 64 + $Random(33)
	for {
    	set temp = temp _ $Char(65 + $Random(25)) // over googol combinations!
    	quit:$Length(temp)>length
	}
	set ^TerminalAuthKey = temp
]]></Implementation>
</Method>

<Method name="GetAuthKey">
<Description>
Returns key for client authorization.
If the key is empty, generates new key value.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($get(^TerminalAuthKey) = "") {
		Do ..GenerateAuthKey()
	}
	quit ^TerminalAuthKey
]]></Implementation>
</Method>

<Method name="SendData">
<Description><![CDATA[
Sends message to client. Prefix and query are optional parameters
@param prefix
		Declares first symbol in a query, for example, ">" to simple message]]></Description>
<FormalSpec>prefix:%Char="",query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	do ..Write(prefix _ query)
]]></Implementation>
</Method>

<Method name="ExecuteCommand">
<Description>
The heart of terminal application</Description>
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (query = "") quit $$$OK
	
	set commands = $LISTFROMSTRING(query,$CHAR(10)) // break command by lines (multilining)
		
	FOR i=1:1:$LISTLENGTH(commands) {
		
		set error = "" // clear error
		#dim exception as %Exception.AbstractException
		
    	set value = $LIST(commands,i) // split received data by lines
    	
    	write ..MESSAGE // write message identifier to stack
    	
    	try {
	    	
	    	xecute value // just xecute
				
    	} catch exception {
	    	
	    	write exception.DisplayString()
	    	
    	}
    	
    	Do ..SendData()
    	
    }
    
    if (..CurrentNamespace '= $Znspace) { // change client namespace
	    Set ..CurrentNamespace = $Znspace
	 	Do ..SendData(..CHANGENAMESPACE,..CurrentNamespace)   
    }
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="ClientLoop">
<Description><![CDATA[
Main method for every new client.

Authorization process description:
	1.	Client requests cache server page called "WebTerminal.csp";
	2.	Server return this page with ClassMethod GetAuthKey() value;
	3.	After client receives page, it performs websocket connection;
		to same web-resource, but with next URL changes:
		"http://" -> "ws://", "WebTerminal.csp" -> "Webterminal.Engine.cls";
	4.	After connection established, client sends his AuthKey to server
		and removes it locally (because it needed only one time);
	5.	Server compares again received key with ..GetAuthKey() value and
		grants permission, if keys are equal.
	>>	As a result - there is no way to autorize via websocket without
		accessing WebTerminal.csp.

Method description:
	First, method requires from client
	a key, which will be compared with ..GetAuthKey() (global). If 
	succeeded, method sets "authorized" flag to true and changes global
	key with ..GenerateAuthKey() for the next client.]]></Description>
<FormalSpec>clientID:%Numeric</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	set authorized = 0 // client autorization required
	
	for {
		
		set readedData = ..Read(,.status)
    
    	if $$$ISOK(status) {
	    	
	    	set action = $Extract(readedData,1,1) // read first character of data to determine action
	    	set data = $Extract(readedData,2,) // data after first character
	    		    	
	    	if (action = ..AUTHORIZATION) { // autorize
			    
			    if (data = ..GetAuthKey()) {
				    
				    set authorized = 1
				    do ..SendData(..MESSAGE,"Authorization succeeded! " _
				    "Your client id: " _ ..SessionId)
				    set ..CurrentNamespace = $Znspace
				    do ..SendData(..CHANGENAMESPACE,..CurrentNamespace) // change client namespace
				    	
			    } else {
				    
				    do ..SendData(..MESSAGE,"Wrong auth key, so... " _
				    "Good bye, brother!")
				    do ..EndServer()
				    
			    }
			    
			    do ..GenerateAuthKey() // client fails/logins. Generate new key in both situations.
			    	
		    } elseif (authorized = 0) {
			    	
			    do ..SendData(..AUTHORIZATION,"Authorization required.")
			    	
		    } elseif (action = ..MESSAGE) { // autorized
	    	
		    	do ..ExecuteCommand(data)	    	
		    	
	    	} else { // something scary
		    	
		    	do ..SendData(..MESSAGE,"Unrecognised query.")
		    		
	    	}
      		
    	} else { // $$$ISOK(status)
	    	 
      		quit:($$$GETERRORCODE(status)=$$$CSPWebSocketClosed)
    
    	}
	} // for
]]></Implementation>
</Method>

<Method name="Server">
<Description>
New connection established</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ..lastClientId = ..lastClientId + 1
	
	if (^TerminalAuthKey '= "") {
		Do ..ClientLoop(..lastClientId)
	}
  	
  	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// $Server

]]></Content>
</UDLText>
</Class>
</Export>
