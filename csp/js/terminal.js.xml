<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<CSP name="js/terminal.js" application="/csp/zitro/" default="1"><![CDATA[
/**
 * Basic scripts for web-based Cache terminal.
 *
 * @author ZitRo
 *
 * Required:
 *  parser.js
 *  base.js
 */

var autocompleteVariants = []; // currently available variants of autocomplete

var terminalRedefined = []; // holds user-defined words that are stored in  //  terminalRedefined[i] = "word"
var terminalDefines = []; // holds redefinition of defined words  //  terminalDefines["word"] = "word"

/**
 * Actions are used as server-client communication prefixes and shows what action server/client have to perform.
 * For example, message from server ">test" means, that client must put to log text "test", when message "_USER"
 * meaning is to change current namespace to USER.
 *
 * @type {string}
 */
var ACTION_MESSAGE = ">",// stores message. Second separator means for server that message has it's own id
    ACTION_AUTHORIZATION = "?",// used to authorize client, holds authorization key
    ACTION_NAMESPACE = "_", // holds namespace to change
    ACTION_EXECUTED = "!"; // holds the id of message that has been just executed

/**
 * Functions terminalGet*Object[s] return objects (terminal parts) to work with.
 *
 * @returns {object} 
 *  Returns required object.
 */
function terminalGetInputObject() { return document.getElementsByClassName("terminalHiddenInput")[0] }
function terminalGetInputViewObject() { return document.getElementsByClassName("terminalInputView")[0] }
function terminalGetOutputObject() { return document.getElementsByClassName("terminalOutput")[0] }
function terminalGetInputWrappersObjects() { return document.getElementsByClassName("terminalInputWrapper") }
function terminalGetInputHeaderObject() { return document.getElementsByClassName("terminalInputHeader")[0] }
function terminalGetCaretObject() { return document.getElementsByClassName("caret")[0] ||
    document.getElementsByClassName("caret-blink")[0] }
function terminalGetAutocompleteObject() { return document.getElementsByClassName("terminalAutocompleteOption")[0] }
function terminalGetOutputMessage(id) { return document.getElementById("terminalCommand"+id) }

/**
 * Focuses on terminal input object.
 */
function terminalFocusOnInput() {
    terminalGetInputObject().focus();
    placeCaretAtEnd(terminalGetInputObject());
}

/**
 * Function by default called every .5-1 second and does input caret blink.
 */
function terminalCaretTick() {
    var caret = terminalGetCaretObject();
    if (caret) (caret.getAttribute("class") == "caret-blink") ?
        caret.setAttribute("class", "caret") :
        caret.setAttribute("class", "caret-blink");
}

/**
 * Sets current command zone to zoneName.
 *
 * @param zoneName
 *  Command zone.
 */
function terminalSetCommandZone(zoneName) {

    var header = terminalGetInputHeaderObject();
    var wrappers = terminalGetInputWrappersObjects();

    // we need to update terminalInputHeader.width && terminalInputWrappers[].margin-left property

    var l = zoneName.visualLength() + 20; // @const
    var length = wrappers.length;

    for (var i = 0; i < length; i++) {
        wrappers[i].style.marginLeft = l + "px";
    }

    header.style.width = l + "px";
    header.innerHTML = zoneName;

}

/**
 * Function returns current working command zone.
 *
 * @returns {string}
 *  E.g. Namespace
 */
function terminalGetCommandZone() {
    return terminalGetInputHeaderObject().innerHTML;
}

/**
 * Returns data typed to terminal input field.
 *
 * @returns {string}
 *  Value of terminal input
 */
function terminalGetInputValue() {
    var input = terminalGetInputObject();
    return input.value;
}

/**
 * Sets the value of terminal input object.
 */
function terminalSetInputValue(value) {

    var input = terminalGetInputObject();
    input.value = value;
    placeCaretAtEnd(input);

}

/**
 * Returns data within terminal input (highlighted).
 *
 * @returns {string}
 *  Value of terminal input
 */
function terminalGetInputViewValue() {
    var input = terminalGetInputViewObject();
    return input.innerHTML;
}

/**
 * Outputs data to terminal output.
 * @param data
 *  Data to output.
 * [ @param highlight ]
 *  Set to positive if it is necessary to highlight output. Default: no highlight.
 * [ @param zone ]
 *  Set output visible zone to any zone you want. If not defined, default zone will be used.
 * [ @param id ]
 *  Insert command identifier.
 */
function terminalOutput(data, highlight, zone, id) {

    highlight = (typeof highlight !== "undefined") ? highlight : 0;
    id = ((typeof id !== "undefined") && (typeof terminalGetOutputMessage(id) !== "undefined"))?" id=\"terminalCommand"+id+"\"":"";
    zone = (typeof zone !== "undefined") ? zone : terminalGetCommandZone();
    var output = terminalGetOutputObject();

    data = ((highlight)?parserHighlight(data):data);//.replace(/\n/g,"<br>");
    //text = htmlEncode(text);
    //text = parserFillHTMLSpaces(text);
    //text = (highlight)?parserHighlight(data):data;

    //visualLength

    output.innerHTML += "<div class=\"terminalOutputMessage\""+id+">"+
        "<span class=\"terminalOutputHeader\">" + zone + "</span>"+
        "<span class=\"terminalOutputBody\">"+
        data +"</span></div>";

}

/**
 * Submits data from terminal input to server with all necessary actions. Clears input.
 */
function terminalSubmit(data) {

    if (data.trim() != "") {

        data = parserReplaceUserRedefinitions(data);

        if (handleInput) { // scenario script

            terminalHandledInput(data);

        } else {

            var odata = htmlEncode(data);
            odata = parserFillHTMLSpaces(data);
            terminalOutput(odata, 1, terminalGetCommandZone(), lastCommandId+1);

            lastCommandId++;
            historyCurrent = commandHistory.length;
            commandHistory[historyCurrent - 1] = terminalGetInputValue();
            commandHistory.push("");

            if (data[0]=="/") { // internal (browser-side) instruction

                terminalInternalExecute(data.substr(1,data.length-1));

            } else {

                terminalExecute(data);

            }

        }


    } else terminalOutput(""); // just for geeks :)

    terminalClearInput();
    terminalUpdateInputView();
    scrollToBottom(document.body);
    log(terminalGetInputValue());

}

/**
 * Function clears all visual logs
 */
function terminalClearLog() {
    terminalGetOutputObject().innerHTML = ""
}

/**
 * Function clears all command history
 */
function terminalClearHistory() {
    commandHistory = [""];
    historyCurrent = 0;
}

/**
 * Function executes every submit time when handleInput flag equals true.
 *
 * @param data
 *  Input data.
 */
function terminalHandledInput(data) {

    handleInput = 0;
    var zone = terminalGetCommandZone();
    if (zone == "login") {
        tempStack = data;
        terminalSetCommandZone("password");
        terminalGetInputViewObject().style.visibility = "hidden";
        handleInput = 1;
    } else if (zone == "password") {
        terminalGetInputViewObject().style.visibility = "visible";
        tempStack += "?"+data;
        terminalSetCommandZone("server");
        terminalExecute(tempStack,ACTION_AUTHORIZATION);
        tempStack = "";
    }

}

/**
 * Function called when message received from the server.
 *
 * @param event
 *  Event data.
 */
function terminalMessageReceived(event) {

    var data = event.data; if (data.length < 2) return;
    var action = data[0]; data = data.substr(1);

    switch (action) {

        case ACTION_AUTHORIZATION: {
            terminalOutput("Please, authorize first:",1,"server");
            handleInput = 1;
            terminalSetCommandZone("login");
        } break;

        case ACTION_MESSAGE: {
            terminalOutput(parserFillHTMLSpaces(htmlEncode(data)),1,"<span class=\"info\">"+terminalGetCommandZone()+"</span>");
        } break;

        case ACTION_NAMESPACE: {
            terminalSetCommandZone(data);
        } break;

        case ACTION_EXECUTED: {
            terminalMarkOutputMessageAsExecuted(data);
        } break;

        default: {
            terminalOutput("Something scary received from the server. Unrecognised action "+action+", data: "+data,1,terminalGetCommandZone());
        }

    }

    scrollToBottom(document.body);

}

function terminalMarkOutputMessageAsExecuted(messageId) {

    var obj = terminalGetOutputMessage(messageId);
    if (obj) {
        var header = obj.firstChild;
        if (header) {
            header.innerHTML = "<span class=\"executed\">" + header.innerHTML + "</span>"
        }
    } else {
        log("Message with id="+messageId+" executed, but log of this message does not exists (or just was cleared).")
    }

}

/**
 * Executes command on server side. Simply sends command to server.
 *
 * @param command
 *  Command to execute.
 * [ @param action ]
 *  Action prefix for server. Default: ACTION_MESSAGE.
 */
function terminalExecute(command,action) {

    if (typeof action == "undefined") action = ACTION_MESSAGE;
    var data = parserPrepareSubmitData(command);
    if (action == ACTION_MESSAGE) data = lastCommandId + ACTION_MESSAGE + data;

    if (webSocket == null) {
        terminalOutput("No connection established. Please, use <span class=\"hint\">/connect</span> command first.",
            0,"<span class=\"error\">system</span>");
    } else try {
        //log("sending: ",action + data);
        webSocket.send(action + data);
    } catch (e) {
        terminalOutput("Problems with <b>WebSocket</b>. Exception: " + e,
            0,"<span class=\"error\">system</span>");
    }

}

function terminalSaveCurrentQueryToHistory() {
    commandHistory[commandHistory.length-1] = terminalGetInputValue();
}

/**
 * Clears input of the terminal.
 */
function terminalClearInput() {

    terminalGetInputObject().value = "";
    placeCaretAtEnd(terminalGetInputObject());

}

/**
 * Performs suitable actions for terminal input, basing on keyPress event:
 * - Performs submitting while enter pressed;
 * - Prevents and handles <tab> key press;
 *
 * @param event
 *  Key press event.
 */
function terminalKeyDowned(event) {

    var keyCode = getKeyCode(event);

    if ( keyCode == 9 || (keyCode == 13 && !(keyPressed[16] || keyPressed[17])) || keyCode == 17) {
        preventDefaultEvent(event);
    } else {
        setTimeout("terminalSaveCurrentQueryToHistory()",1);
    } // letter pressed

    if (keyCode != 13 || ( keyCode == 13 && !(keyPressed[16] || keyPressed[17])))
        terminalPerformKeyAction(keyCode); // SHIFT/CTRL + ENTER

    // SHIFT == 16

    if (keyCode != 17) setTimeout("terminalUpdateInputView()",1); // CTRL

}

/**
 * Function focuses on terminal input, if focus locates somewhere else and
 * calls terminalKeyDowned(event) function.
 *
 * @param event
 *  Keyboard event.
 */
function terminalGlobalKeyDown(event) {

    if (document.activeElement != terminalGetInputObject()) {
        if (keyPressed[17] == 0)
            terminalFocusOnInput();
    }
    terminalKeyDowned(event);

}

/**
 * Function just updates input view: highlights it and do some other stuff.
 */
function terminalUpdateInputView() {

    terminalGetInputViewObject().innerHTML = parseInput(terminalGetInputValue());

}

/**
 * Just returns value of current autocomplete option.
 *
 * @returns {string}
 *  Part of string autocomplete object holds.
 */
function terminalGetAutocompleteValue() {

    var obj = terminalGetAutocompleteObject();
    return (obj)?terminalGetAutocompleteObject().innerHTML:"";

}

/**
 * Sets value directly to autocomplete object.
 * @param value
 *  Value to set.
 */
function terminalSetAutocompleteValue(value) {

    var obj = terminalGetAutocompleteObject();
    if (obj) { obj.innerHTML = value } else { log("No autocomplete object found to set value to.") }

}

/**
 * Function returns one of query results from command history.
 *
 * @param increment
 *  Relative value to seek in history stack
 *
 * @returns {string}
 *  Command from history.
 */
function terminalLoadFromHistory(increment) {

    historyCurrent += increment;
    if (historyCurrent < 0) historyCurrent = commandHistory.length-1;
    if (historyCurrent >= commandHistory.length) historyCurrent = 0;
    return commandHistory[historyCurrent].toString();

}

/**
 * Inserts autocomplete option (if exists) into current cursor position of input.
 */
function terminalPerformAutocomplete() {

    var input = terminalGetInputObject();
    var caretPosition = getCaretPosition(input);
    var autocompleteValue = terminalGetAutocompleteValue();
    terminalSetInputValue(parserInsertString(terminalGetInputValue(),caretPosition,autocompleteValue));
    setCaretPosition(input,caretPosition + autocompleteValue.length);

}

/**
 * Performs specified action according to key.
 *
 * @param key
 *  Code of trigger key.
 * @returns {number}
 *  Returns default action preventing. If 0, default key pressed action will be performed.
 */
function terminalPerformKeyAction(key) {

    switch (key) {
        case 9: {
            /*if (autocompleteVariants.length == 0) { //TODO: <tab>
                var p = getCaretPosition(terminalGetInputObject());
                var val = terminalGetInputValue();
                log(p,val);
                terminalSetInputValue(val.replaceSymbol(p,val.charAt(p)+"\t"));
                setCaretPosition(terminalGetInputObject(),p+1);
            }*/
            terminalPerformAutocomplete();
        } break; // TAB
        case 13: terminalSubmit( terminalGetInputValue() ); break; // ENTER
        case 17: terminalChangeAutocompleteVariant(); break; // CTRL
        case 38: {
            var caretPos = getCaretPosition(terminalGetInputObject());
            var nPos = terminalGetInputValue().indexOf("\n");
            if (caretPos < nPos || nPos == -1) { // if placed on first line of input
                terminalSetInputValue(terminalLoadFromHistory(-1));
                return 0;
            }
        } break;
        case 40: {
            var caretPos = getCaretPosition(terminalGetInputObject());
            var nPos = terminalGetInputValue().lastIndexOf("\n");
            if (caretPos > nPos || nPos == -1) { // if placed on last line of input
                terminalSetInputValue(terminalLoadFromHistory(1));
                return 0;
            }
        } break;
    }

    return 0;

}

/**
 * Changes variants of autocomplete to one of the next available.
 */
function terminalChangeAutocompleteVariant() {

    var val = terminalGetAutocompleteValue();
    if (val != "") {
        for (var i = 0; i < autocompleteVariants.length; i++) {
            if (autocompleteVariants[i].toLowerCase() == val) {
                var v = (i+1 < autocompleteVariants.length)?autocompleteVariants[i+1]:autocompleteVariants[0];
                terminalSetAutocompleteValue(v);
            }
        }
    }

}

/**
 * Checks for autocomplete in current position and guesses variants
 */
function parserInsertAutocompleteOption(text) {

    var input = terminalGetInputObject();
    var caretPosition = getCaretPosition(input);
    var data = terminalGetInputValue();
    autocompleteVariants = parserGetAutocompleteVariants(data,caretPosition);
    if (autocompleteVariants.length > 0) {
        text = parserInsertString(text,parserGetRealPosition(text,caretPosition),
            "<span class=\"terminalAutocompleteOption\">"+autocompleteVariants[0]+"</span>");
    }
    return text;

}
]]></CSP>
</Export>
