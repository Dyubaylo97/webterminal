<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<CSP name="js/parser.js" application="/csp/zitro/" default="1"><![CDATA[
/**
 * Contains functions that take part in text processing.
 *
 * @author ZitRo
 */

var tAC = ["/help","/clear","/connect","/disconnect","/define","/siege",
    "set","write","zwrite","for","while","kill","quit","close","else","read",
    "select","from","where","join","into",
    "$$$OK","$$$ISERR","$$$ISOK",
    "##class("];

var terminalCleverAutocomplete = {
    "root": {
        "/help": 1,
        "/clear": 0,
        "/connect": 0,
        "/siege": 0,
        "/disconnect": 0,
        "/define": 0
    },
    "class": {
        "%Library": 1,
        "%IO": 0,
        "%System": {
            "Level2": {
                "Level31": {
                    "Level4": 0
                },
                "Level32": {
                    "Level4s": 0
                },
                "Level33": {
                    "LevelO": 0,
                    "LevelK": 0
                }
            },
            "Level22": {
                "LevelA(1)": {
                    "Level4": 0
                },
                "LevelB(2)": {
                    "Level4s": 0
                },
                "LevelC(3)": {
                    "LevelO": 0,
                    "LevelK": 0
                }
            }
        }
    }
};

/**
 * Function removes any tags in content.
 * @param content {string}
 *  String to parse.
 */
function parserRemoveTags(content) { return content.replace(/(<([^>]+)>)/ig, "") }

/**
 * Inserts string to text in position pos. If pos is incorrect, += operation will be performed.
 *
 * @param text 
 *  Text to insert into.
 * @param position
 *  Position where to insert.
 * @param string
 *  String to insert.
 */
function parserInsertString(text,position,string) {
    try {
        text = text.substring(0,position) + string + text.substring(position,text.length);
    } catch (e) { log(e); text += string }
    return text;
}

/**
 * Function returns array of string variants, which best fits in current string position.
 * Note that function try to guess paying attention only to the symbols BEFORE position.
 *
 * @param string
 *  String with some text.
 * @param position
 *  Position in string where function will try to guess.
 * @returns {Array}
 *  Array with possible variants.
 */
function parserGetAutocompleteVariants(string,position) {


    var i = Math.min(position-1,string.length-1), s = '', variants = [];
    if (i<0) return variants;
    if (i+1<string.length && string[i+1].match(/\w/g)) return []; // leave autocomplete if next letter detected
    while (i >= 0) { // get the part of string
        if (string[i].match(/[\w\$%#\.\^/]/g)) s += string[i]; else break;
        i--;
    }
    if (s == '') return [];

    var kk = 0;
    s = s.reverse();
    var l = tAC.length;
    //s = s.toLowerCase();
    for (i= 0; i < l; i++) {
        if (tAC[i].indexOf(s) === 0) { // word beginning
            if (s == tAC[i]) return [];
            variants.push(tAC[i].substring(s.length,tAC[i].length));
            kk++;
        }
    }
    return variants;

}

/**
 * This function searches for ##class(...)... construction in string and returns array of current available variants.
 *
 * @param string
 *  String to search in.\
 * @param position
 *  Position of cursor where autocomplete needed
 * @returns {Array}
 *  Array with available autocomplete variants.
 */
function parserGetCleverAutocompleteVariants(string,position) {

    /*var i = Math.min(position-1,string.length-1), variants = [], s = '', autocompleteRoot = "root";
    if (i<0) return variants;
    if (i+1<string.length && string[i+1].match(/\w/g)) return []; // leave autocomplete if next letter detected
    while (i >= 0) { // get the part of string
        if (string[i].match(/[\w\$\(\)%#\.\^/]/g)) {
            if (string[i].match(/[\.\(\)]/g)) autocompleteRoot = "class";
            s += string[i];
        } else break;
        i--;
    }
    if (s == '') return [];

    var kk = 0;
    s = s.reverse();
    var a = [autocompleteRoot].concat(s.split(/\.|\(|\)/g));
    if (a[1] == "") { a.splice(1,1) }
    if (a[a.length-1] == "" && a[a.length-2] == "") { a.splice(a.length-1,1) }
    //log(a);
    var l = a.length; s = "";
    for (i = 0; i<l-1; i++) s+="[\""+a[i]+"\"]";
    var end = a[i] || "";
    //log("Apatch: ",s);
    var b = {}; eval("try {b = terminalCleverAutocomplete"+s+"} catch (e) {};");
    //log("AC Obj: ",b);
    for(var pName in b) {
        //log("checking ",pName, "=", end);
        if (b.hasOwnProperty(pName) && pName.indexOf(end) === 0) { // word beginning
            variants.push(pName.substring(end.length,pName.length));
            kk++;
        }
    }
    return variants;*/

    var completeClassPattern = function(acOption) {

        var variants = [], kk = 0;

        for (var i = 0; i < tAC.length; i++) { // find in whole autocomplete base
            if (tAC[i].indexOf(acOption) === 0) { // word beginning
                if (tAC[i].replace(acOption,"").charAt(0) == ".") return [];
                var option = tAC[i].substring(acOption.length,tAC[i].length);
                option = (option.charAt(0) == ".")?option.split(/\./g)[1]:option.split(/\./g)[0];
                variants.push(option);
                //log(tAC[i] + " <=> " + acOption);
                kk++;
            }
        }

        log("Class autocomplete variants: ", kk + "/" + tAC.length);

        return variants;

    };

    var PARSE_TYPE = 0; // 0: simple; 1: class

    var formPattern = function(string,position) {

        if (string.match(/##class\(%?[a-zA-Z\.]*\)?\.?[a-zA-Z\.]*\(?\)?/g)) {
            var temp = string.match(/##class\(%?[a-zA-Z\.]*\)?\.?[a-zA-Z\.]*\(?\)?/g);
            if (temp) temp = temp[0];
            //log("TRY: " + (string.lastIndexOf(temp) + temp.length) + " == " + position);
            if (string.lastIndexOf(temp) + temp.length == position) {
                PARSE_TYPE = 1;
                return temp;
            }
        }

        var i = string.length- 1, breakSymbol = 0;
        while (i>0) {
            if (string[i].match(/[\$%#\^/]/g)) {
                //log("bs: "+i+": "+string[i].match(/[\w\$%#\.\^/]/g));
                breakSymbol = 1
            } else if (breakSymbol) { // no other break symbols
                //log("goodbye: "+i);
                return string.substr(i+1,string.length-i);
            } else if (string[i].match(/\w/g)) {

            } else {
                string = string.substr(i+1,string.length-i);
                break;
            }
            i--;
        }

        return string;

    };

    position = Math.min(string.length,position);
    if (string.charAt(position).match(/\w/g)) return []; else string = string.substring(0,position);

    string = formPattern(string,position);
    //log(string, " BY TYPE: " + PARSE_TYPE);
    if (string == "") return [];

    //log(pattern);
    if (PARSE_TYPE == 1) {
        var pattern = string.split(/##class\(|\)\.|\./g).slice(1).join(".");
        if (pattern) return completeClassPattern(pattern);
    } else if (PARSE_TYPE == 0) {
        return completeClassPattern(string)
    }
    //var arr = (pattern && typeof pattern == "object")?pattern[0].match(/[A-Za-z]+[A-Za-z0-9]*/g):null;

    /*if (PARSE_TYPE == 1 && arr && arr.length > 0 && arr.splice(0,1)[0] == "class") {

        return completeClassPattern(arr);

    }*/

    return [];

}

/**
 * Analyzing stringPart, function returns correct name of element to use.
 * Usage: for example, to form highlighting "class" attribute. "set" -> "-set"
 * "$function" -> "-f_function", "$$$macro" -> "-m_macro" etc.
 *
 * @param stringPart
 *  Part of string, which name needed to return.
 */
function parserSyntaxGetAttrName(stringPart) {

    var result = null;
    if (stringPart.match(/^[a-zA-Z][a-zA-Z0-9]*$/)) { // simple words
        result = stringPart.toLowerCase();
    } else if (stringPart.match(/^[0-9]+$/)) {
        result = "_digit"
    } else if (stringPart.match(/^".*"$/)) {
        result = "_string"
    } else if (stringPart.match(/^\$[a-zA-Z][a-zA-Z0-9]*$/)) {
        result = "_function"
    } else if (stringPart.match(/^\$\$[a-zA-Z][a-zA-Z0-9]*$/)) {
        result = "_userFunction"
    } else if (stringPart.match(/^[{}\]\[\(\)]+$/)) {
        result = "_bracket"
    } else if (stringPart.match(/^\^[a-zA-Z][a-zA-Z0-9]*$/)) {
        result = "_global"
    } else if (stringPart.match(/^##[a-zA-Z][a-zA-Z0-9]*$/)) {
        result = "_sysMacro"
    } else if (stringPart.match(/^\.\.[a-zA-Z][a-zA-Z0-9]*$/)) {
        result = "_classProp"
    } else if (stringPart.match(/^\$\$\$[a-zA-Z][a-zA-Z0-9]*$/)) {
        result = "_macro"
    } else if (stringPart.match(/^[\+\-=\*\/<>\\!_'#\?]+$/)) {
        result = "_symbol"
    } else { result = "_other" }
    return (result)?"-"+result:result;

}

/**
 * Parses text for tags and unnecessary symbols and returns correct text ready to execute on server side.
 *
 * @param data
 *  not formatted string which must be prepared to execute on server side
 * @returns {string}
 *  formatted string ready-to-execute on server side
 */
function parserPrepareSubmitData(data) {
    return parserRemoveTags(data).trim().replace(/\r\n|\r|\n/g,"\n") + "\n"; // adds last terminator character
}

/**
 * Function inserts color tags to string and returns string with tags.
 *
 * @deprecated
 *
 * @param string
 *  String to highlight.
 * @returns {string}
 *  Highlighted string.
 */
function parserHighlight(string) {

    return string.replace(/(\w+|\W)/g, function(a) {  // \S+   //  \w+

        if (a.match(/(lt|gt|<|>|&|br|nbsp|amp|;)/g) || // html special characters
            //a.match(/^[^\s]*<div$/) ||
            //a.match(/^class="caret-blink"><\/div>[^\s]*$/)) {
            a.match(/.*(<|>).*/g)) { // any tag symbol
            return a; // just skip
        }
        return "<span class=\"syntax" + parserSyntaxGetAttrName(a) + "\">" + a + "</span>";

    });

}

/**
 * Function breaks code for parts with span tags and according styles, but skips &*; html-symbol combinations and tag <br>
 *
 * @param string
 *  String to parse.
 * @returns {string}
 *  Parsed string.
 */
function parserHighlightHTML(string) {
    return string.replace(/(((<|&|&#)|\^|\${0,3}|#{0,2}|%|\.|(\.\.))?[A-Za-z0-9]+[;>]?)|[{}\]\[\(\)!_'\\#\?\+\-\*\/=<>,]|("[^"]*")/g,
        function(part) {
            return "<span class=\"syntax" + parserSyntaxGetAttrName(part) + "\">" + part + "</span>";
    });
}

/**
 * Function returns real position in string, according to visible position pos.
 * In other words, it skips tags and special html symbols like &nbsp;
 *
 * @param string
 *  String
 * @param position
 *  Position to convert.
 * @returns {number}
 *  New real position according to html-string.
 */
function parserGetRealPosition(string,position) {

    var i = 0, l = string.length, pos = 0;
    while (i<l && pos<position) {
        if (string[i]=="&") {
            var m = string.substr(i+1,5).match(/(nbsp|lt|gt|amp|#09);/g);
            if (m) i += m[0].length;
        } else if (string[i]=="<") {
            var p = string.indexOf(">",i+1);
            var inside = string.substring(i+1,p);
            if (inside == "br" || inside.substr(0,3) == "br/" || inside.substr(0,3) == "br ") {
                pos++;
            }
            if (p==-1) { i = pos = l-1 } else { i += p-i; pos--; }
        }
        pos++; i++;
    }
    return i;
}

/**
 * Function inserts caret html code to position, missing tags and &nbsp; symbols.
 * With any problems caret will be inserted at the end.
 *
 * @param text
 *  Text insert to.
 * @param position
 *  Position where to insert without tags.
 * @returns {string}
 *  String with caret code inside.
 */
function parserInsertCaret(text,position) {

    return parserInsertString(text,parserGetRealPosition(text,position),"<div class=\"caret-blink\"></div>");

}

/**
 * Replaces space characters and line endings to make it correctly displayed after insertion to html code.
 *
 * @param text
 *  Text where to replace.
 *
 * @returns {string}
 *  Replaced text.
 */
function parserFillHTMLSpaces(text) {

    if (text.length>0) {
        if (text[text.length-1] == " ") text = text.replaceSymbol(text.length - 1,"&nbsp;");
        if (text[0] == " ") text = text.replaceSymbol(0,"&nbsp;");
        text = text.replace(/\n/g,"<br>").replace(/  /g,"&nbsp;&nbsp;").replace(/>\s/g,">&nbsp;");
    }

    return text;//.replace(/\t/g,"<span class=\"tab\">&nbsp;</span>");

}

/**
 * Replaces all user-defined symbols/words.
 *
 * @param text
 *  Text where to search.
 * @returns {string}
 *  Replaced string.
 */
function parserReplaceUserRedefinitions(text) {

    var regex = null, def = null;
    if (typeof terminalRedefined == "undefined") return text;
    for (var i = 0; i < terminalRedefined.length; i++) {
        def = terminalRedefined[i];
        if (def) {
            regex = new RegExp(escapeRegExp(def), 'g');
            log(regex);
            text = text.replace(regex,terminalDefines[def]);
        }

    }

    return text;

}

/**
 * Function parses input text for view. Adds styles, etc.
 *
 * @param text
 *  Text to parse.
 * @return {string}
 *  Parsed stylized string.
 */
function parseInput(text) {

    var p = getCaretPosition(terminalGetInputObject());

    text = htmlEncode(text);
    text = parserHighlightHTML(text);
    //text = parserFillHTMLSpaces(text);
    //text = parserHighlight(text);
    text = parserInsertAutocompleteOption(text);
    if (!ie()) text = parserInsertCaret(text,p); // do not show caret in IE - here's the native caret impossible to hide

    return text;

}
]]></CSP>
</Export>
