<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="%WebTerminal.Engine">
<Description>
Cache WEB Terminal vX.X.X/*build.replace:pkg.version*/
This class is the core of web terminal application.</Description>
<Super>%CSP.WebSocket,%Library.Routine</Super>
<TimeCreated>63891,56786.028532</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// CONSTANTS BEGIN

]]></Content>
</UDLText>

<Parameter name="authorizationTimeout">
<Description>
How long to wait for authorization key when connection established</Description>
<Default>5</Default>
</Parameter>

<Property name="ConstServerActionExecute">
<Type>%Char</Type>
<InitialExpression>"EXEC"</InitialExpression>
</Property>

<Property name="ConstServerActionExecuteSQL">
<Type>%Char</Type>
<InitialExpression>"SQL"</InitialExpression>
</Property>

<Property name="ConstServerActionGenerateAutocomplete">
<Type>%Char</Type>
<InitialExpression>"AC"</InitialExpression>
</Property>

<Property name="ConstServerActionTrace">
<Type>%Char</Type>
<InitialExpression>"TRACE"</InitialExpression>
</Property>

<Property name="ConstServerActionStopTraceAll">
<Type>%Char</Type>
<InitialExpression>"STOP_TRACE_ALL"</InitialExpression>
</Property>

<Property name="ConstServerActionCheckTrace">
<Type>%Char</Type>
<InitialExpression>"CT"</InitialExpression>
</Property>

<Property name="ConstServerActionReset">
<Type>%Char</Type>
<InitialExpression>"R"</InitialExpression>
</Property>

<Property name="ConstServerActionEcho">
<Type>%Char</Type>
<InitialExpression>"E"</InitialExpression>
</Property>

<Property name="ConstServerActionCheckUpdate">
<Type>%Char</Type>
<InitialExpression>"CU"</InitialExpression>
</Property>

<Property name="ConstServerActionUpdate">
<Type>%Char</Type>
<InitialExpression>"U"</InitialExpression>
</Property>

<Property name="ConstClientPrompt">
<Type>%String</Type>
<InitialExpression>"PROMPT#"</InitialExpression>
</Property>

<Property name="ConstClientStartExec">
<Type>%String</Type>
<InitialExpression>"EST#"</InitialExpression>
</Property>

<Property name="ConstClientEndExec">
<Type>%String</Type>
<InitialExpression>"END#"</InitialExpression>
</Property>

<Property name="ConstClientOutputMessage">
<Type>%String</Type>
<InitialExpression>"O#"</InitialExpression>
</Property>

<Property name="ConstClientOutputLocalized">
<Type>%String</Type>
<InitialExpression>"OL#"</InitialExpression>
</Property>

<Property name="ConstClientChangeNamespace">
<Type>%String</Type>
<InitialExpression>"NS#"</InitialExpression>
</Property>

<Property name="ConstClientLoadAutocomplete">
<Type>%String</Type>
<InitialExpression>"AC#"</InitialExpression>
</Property>

<Property name="ConstClientReadString">
<Type>%String</Type>
<InitialExpression>"R#"</InitialExpression>
</Property>

<Property name="ConstClientReadChar">
<Type>%String</Type>
<InitialExpression>"RC#"</InitialExpression>
</Property>

<Property name="ConstClientAuthorizationStatus">
<Type>%String</Type>
<InitialExpression>"AUTH#"</InitialExpression>
</Property>

<Property name="ConstClientTrace">
<Type>%String</Type>
<InitialExpression>"TRACE#"</InitialExpression>
</Property>

<Property name="ConstClientStopTrace">
<Type>%String</Type>
<InitialExpression>"STOP_TRACE#"</InitialExpression>
</Property>

<Property name="ConstClientLoginInfo">
<Type>%String</Type>
<InitialExpression>"I#"</InitialExpression>
</Property>

<Property name="ConstClientClearScreen">
<Type>%String</Type>
<InitialExpression>"CLRSCR#"</InitialExpression>
</Property>

<Property name="ConstClientPromptUpdate">
<Type>%String</Type>
<InitialExpression>"PROMPT_UPDATE#"</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
// CONSTANTS END

]]></Content>
</UDLText>

<Property name="SharedConnection">
<Description><![CDATA[
This property determines whether the communication between the client and WebSocket server should be over a dedicated Gateway
connection or over a pool of shared connections.  It may be set to one of the following:
<br><ul>
<li><b>SharedConnection=0</b> - The WebSocket server communicates with the client via a dedicated Gateway connection. In this mode of operation the hosting connection is effectively 'private' to the application session.</li>
<li><b>SharedConnection=1</b> - The WebSocket server communicates asynchronously with the client via a fixed number of shared Gateway connections.</li>
</ul>]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="CurrentNamespace">
<Type>%String</Type>
</Property>

<Property name="InitialZName">
<Type>%String</Type>
</Property>

<Property name="InitialZNamespace">
<Type>%String</Type>
</Property>

<Property name="Watches">
<Description>
Property is used to store watching files/globals. </Description>
<Type>%List</Type>
</Property>

<Property name="WatchesCaret">
<Description>
Watch position in file on global</Description>
<Type>%Numeric</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="redirects">
<Description>
Public point entries, using when redirecting i/o</Description>
<Private>1</Private>
<ProcedureBlock>0</ProcedureBlock>
<Implementation><![CDATA[
/// Mnemonics
APC d APC^%X364 q
BEL d BEL^%X364 q
CBT(%1) d CBT^%X364(%1) q
CCH d CCH^%X364 q
CHA(%1) d CHA^%X364(%1) q
CHT(%1) d CHT^%X364(%1) q
CNL(%1) d CNL^%X364(%1) q
CPL(%1) d CPL^%X364(%1) q
CPR d CPR^%X364 q
CTC(%1,%2,%3,%4,%5,%6,%7,%8,%9) d CTC^%X364(%1,%2,%3,%4,%5,%6,%7,%8,%9) q
CUB(%1) d CUB^%X364(%1) q
CUD(%1) d CUD^%X364(%1) q
CUF(%1) d CUF^%X364(%1) q
CUP(%2,%1) d CUP^%X364(%2,%1) q
CUU(%1) d CUU^%X364(%1) q
CVT(%1) d CVT^%X364(%1) q
DA d DA^%X364 q
DAQ(%1,%2,%3,%4,%5,%6,%7,%8,%9) d DAQ^%X364(%1,%2,%3,%4,%5,%6,%7,%8,%9) q
DCH(%1) d DCH^%X364(%1) q
DCS d DCS^%X364 q
DL(%1) d DL^%X364(%1) q
DMI d DMI^%X364 q
DSR(%1) d DSR^%X364(%1) q
EA(%1) d EA^%X364(%1) q
ECH(%1) d ECH^%X364(%1) q
ED(%1) d ED^%X364(%1) q
EF(%1) d EF^%X364(%1) q
EL(%1) d EL^%X364(%1) q
EMI d EMI^%X364 q
EPA d EPA^%X364 q
ESA d ESA^%X364 q
FNT d DNT^%X364 q
GSM d GSM^%X364 q
GSS d GSS^%X364 q
HPA(%1) d HPA^%X364(%1) q
HPR(%1) d HPR^%X364(%1) q
HTJ d HTJ^%X364 q
HTS d HTS^%X364 q
HVP(%1,%2) d HVP^%X364(%1,%2) q
ICH(%1) d ICH^%X364(%1) q
IL(%1) d IL^%X364(%1) q
IND d IND^%X364 q
INT d INT^%X364 q
JFY d JFY^%X364 q
MC d MC^%X364 q
MW d MW^%X364 q
NEL d NEL^%X364 q
NP(%1) d NP^%X364(%1) q
OSC d OSC^%X364 q
PLD d PLD^%X364 q
PLU d PLU^%X364 q
PM d PM^%X364 q
PP(%1) d PP^%X364(%1) q
PU1 d PU1^%X364 q
PU2 d PU2^%X364 q
QUAD d QUAD^%X364 q
REP d REP^%X364 q
RI d RI^%X364 q
RIS d RIS^%X364 q
RM(%1,%2,%3,%4,%5,%6,%7,%8,%9) d RM^%X364(%1,%2,%3,%4,%5,%6,%7,%8,%9) q
SEM d SEM^%X364 q
SGR(%1,%2,%3,%4,%5,%6,%7,%8,%9) d SGR^%X364(%1,%2,%3,%4,%5,%6,%7,%8,%9) q
SL d SL^%X364 q
SM(%1,%2,%3,%4,%5,%6,%7,%8,%9) d SM^%X364(%1,%2,%3,%4,%5,%6,%7,%8,%9) q
SPA d SPA^%X364 q
SPI d SPI^%X364 q
SR d SR^%X364 q
SS2 d SS2^%X364 q
SS3 d SS3^%X364 q
SSA d SSA^%X364 q
ST d ST^%X364 q
STS d STS^%X364 q
SU d SU^%X364 q
TBC d TBC^%X364 q
TSS d TSS^%X364 q
VPA(%1) d VPA^%X364(%1) q
VPR(%1) d VPR^%X364(%1) q
VTS d VTS^%X364 q

PrepareOutput(data)
    Try { Set data=$zconvert(data, "O", "UTF8") } Catch {  }
    quit data

PrepareInput(data)
    Try { Set data=$zconvert(data, "I", "UTF8") } Catch {  }
    quit data

/// Routine from %CSP.WebSocket.cls
ReadMessage(len = 32656, timeout = 86400, BytesAvailable, AtEnd, data, data1, header, size, type)
    Set $ZTrap="ReadError"
    If len<1 Set len=32656
    //If (..SharedConnection = 1) {
    //    Set data=..ReadAsync(.len, .sc, timeout)
    //    Try { Set data1=$zconvert(data,"I","UTF8") } Catch { Set data1=data }
    //    Set len=$Length(data1)
    //    Quit data1
    //}
    Set BytesAvailable=0, AtEnd=0
    Read header#5:timeout
    If $Test=0 {
        Set len=0
        //Set sc=$$$ERROR($$$CSPWebSocketTimeout, "WebSocket Read Operation timed-out")
        Set AtEnd=1
        Quit ""
    }
    Set type=$Extract(header,5)
    If type=9 {
        Set len=0
        //Set sc=$$$ERROR($$$CSPWebSocketClosed,"WebSocket Closed by the Client")
        Set AtEnd=1
        Quit ""
    }
    Set header=$Extract(header, 1, 4)
    Set size=$ZLA(header)-1 If size<0 Set size=0
    Set BytesAvailable=size
ReadData
    If BytesAvailable > len {
        Set size=len
        Set BytesAvailable=BytesAvailable-len
    }
    else {
        Set size=BytesAvailable
        Set BytesAvailable=0
    }
    If 'BytesAvailable Set AtEnd=1
    If size=0 Set len=0 Quit ""
    Read data#size
    Set len=size
    //Set sc=$$$OK
    Try { Set data1=$zconvert(data,"I","UTF8") } Catch { Set data1=data }
    Set len=$Length(data1)
    Quit data1
ReadError
    #; No interrupts during cleanup or error processing
    $$$SetExternalInterrupts(0)
    Set $ZTrap="ReadHalt"
    Hang 5
    Close 0
ReadHalt
    Halt

/// Workaround for Cache 2015
#define WSProtocol (##class(%Dictionary.CompiledProperty).%OpenId("%CSP.WebSocket||WSClassProtocolVersion"))
WriteMessage(data, data1, head)
    if ($$$WSProtocol) && ($$$WSProtocol.InitialExpression > 1) {
        try { set data1 = $zconvert(data, "O", "UTF8") } catch { set data1 = data }
        set head = $ZLChar($Length(data1))
        set head = head _ "7"
        write head _ data1, *-3
    } else {
        write $$PrepareOutput(data), *-3
    }
    quit

//////////////////////////////////////////////

wstr(s)
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("O#"_s)
    do ##class(%Device).ReDirectIO($$$YES)
    set $X = $X + $LENGTH(s)
    set $Y = $Y - 1
    quit

wchr(c)
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("O#"_$c(c))
    do ##class(%Device).ReDirectIO($$$YES)
    set $X = $X + 1
    set $Y = $Y - 1
    quit

wnl
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("O#"_$c(13, 10))
    do ##class(%Device).ReDirectIO($$$YES)
    set $X = 0
    quit

wff
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("CLRSCR#")
    do ##class(%Device).ReDirectIO($$$YES)
    set $Y = 0
    set $X = 0
    quit

wtab(s)
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("O#" _ $C(27) _ "[" _ (s + 1) _ "G")
    do ##class(%Device).ReDirectIO($$$YES)
    set $X = s
    quit

rstr(len = 32656, timeout = 86400, data)
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("R#" _ len)
    s data = $$ReadMessage(len, timeout)
    do ##class(%Device).ReDirectIO($$$YES)
    quit data

rchr(timeout = 86400, data)
    do ##class(%Device).ReDirectIO($$$NO)
    do WriteMessage("RC#")
    set data = $$ReadMessage(, timeout)
    set data = data * 1 // $ASCII($EXTRACT(data,1,1))
    do ##class(%Device).ReDirectIO($$$YES)
    quit data
]]></Implementation>
</Method>

<Method name="OnPreServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set ..InitialZName = $zname
    set ..InitialZNamespace = $znspace
    quit $$$OK
]]></Implementation>
</Method>

<Method name="Trace">
<Description>
Chechs for correct watch source and sets watch target to ..Watches
Returns status of this operation</Description>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set s = $CHAR(0)
    set watches = s _ $LISTTOSTRING(..Watches, s) _ s
    if ($FIND(watches, s_name_s) '= 0) q 0 // if watch already defined

    if ($EXTRACT(name,1,1) = "^") { // watching global
        s g = 0
        try {
            if (($data(@name))'=0) s g = 1
        } catch {  }
        set $ZERROR = ""
        if (g = 1) {
            set ..Watches = ..Watches _ $LISTBUILD(name)
            set ..WatchesCaret(name,0) = $QUERY(@name@(""),-1) // last
            set ..WatchesCaret(name,1) = "?"
            do ..SendData(name, ..ConstClientTrace)
            q 1
        }
    } else { // watch file
        if (##class(%File).Exists(name)) {
            set ..Watches = ..Watches _ $LISTBUILD(name)
            set file = ##class(%File).%New(name)
            set ..WatchesCaret(name,0) = file.Size // current watch cursor position
            set ..WatchesCaret(name,1) = file.DateModified
            do ..SendData(name, ..ConstClientTrace)
            q 1
        }
    }

    q 0
]]></Implementation>
</Method>

<Method name="StopTracing">
<Description>
Removes watch from watches list
Returns success status</Description>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    // absurdly, but working
    set s = $CHAR(0)
    set watches = s _ $LISTTOSTRING(..Watches,s) _ s
    set newWatches = $REPLACE(watches, s_name_s, s)
    set ..Watches = $LISTFROMSTRING($EXTRACT(newWatches, 2, *-1), s)
    if (watches '= newWatches) {
        k ..WatchesCaret(name) // really removed
        do ..SendData(name, ..ConstClientStopTrace)
    }
    quit watches '= newWatches
]]></Implementation>
</Method>

<Method name="ListWatches">
<Description>
Returns a list current watches</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set no=0
    set s = "Watching: " _ $CHAR(10)
    while $LISTNEXT(..Watches, no, value) {
        set s = s_"(pos: "_..WatchesCaret(value,0)_
        "; mod: "_..WatchesCaret(value,1)_") "_value_$CHAR(10)
    }
    q s
]]></Implementation>
</Method>

<Method name="GetTraceGlobalModified">
<Description>
Return null string if global hadn't been updated
This method watches only for tail of global and detects if global still alive</Description>
<FormalSpec>watch</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set data = ""
    if ($data(@watch)=0) {
        do ..StopTracing(watch)
        q "removed"
    }
    for {
        set query = $QUERY(@..WatchesCaret(watch,0))
        quit:query=""
        if (data="") set data = "modified"
        set ..WatchesCaret(watch,0) = query
        set data = data _ $CHAR(13, 10) _ @query
    }
    q data
]]></Implementation>
</Method>

<Method name="GetTraceFileModified">
<FormalSpec>watch</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set file=##class(%File).%New(watch)
    set size = file.Size
    set modDate = file.DateModified
    set output = ""
    if (size < 0) { // file had been deleted

        do ..StopTracing(watch)
        q "removed"

    }

    if (size > ..WatchesCaret(watch, 0)) {

        set output = "updated" _ $CHAR(13, 10)
        set stream=##class(%Stream.FileBinary).%New()
        set sc=stream.LinkToFile(watch)
        do stream.MoveTo(..WatchesCaret(watch, 0) + 1)
        set readed = stream.Read(size - ..WatchesCaret(watch, 0))
        set output=output_readed
        set ..WatchesCaret(watch, 0) = size
        set ..WatchesCaret(watch, 1) = file.DateModified

    } elseif ((size < ..WatchesCaret(watch, 0)) || (file.DateModified '= ..WatchesCaret(watch, 1))) {

        set output = "modified" _ $CHAR(13, 10)
        set output = output _ "Bytes changed: " _ (size - ..WatchesCaret(watch, 0))
        set ..WatchesCaret(watch, 0) = size
        set ..WatchesCaret(watch, 1) = file.DateModified

    } // else file not changed
    q output
]]></Implementation>
</Method>

<Method name="CheckTracing">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set no = 0
    set data = ""
    set overal = ""
    set watchList = ..Watches // do not remove or simplify: ..Watches can be modified
    while $LISTNEXT(watchList, no, value) {
        if ($EXTRACT(value, 1, 1) = "^") {
            set data = ..GetTraceGlobalModified(value)
        } else {
            set data = ..GetTraceFileModified(value)
        }
        if (data '= "") {
            set overal = $ZDATETIME($NOW(),1,1) _ " " _
            value _ ": " _ data _ $CHAR(10)
        }
        set data = ""
    }
    q overal
]]></Implementation>
</Method>

<Method name="OnPostServer">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    kill ^CacheTemp.WebTerminal.Watching
    quit $$$OK
]]></Implementation>
</Method>

<Method name="GetJSAutocompleteFilePath">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set data = ##class(%Library.File).ManagerDirectory()
    set data = ##class(%Library.File).ParentDirectoryName(data)

    set dataTest = ##class(%Library.File).SubDirectoryName(data, "CSP")
    if (##class(%Library.File).DirectoryExists(dataTest)) {
        set data = ##class(%Library.File).SubDirectoryName(data, "CSP")
    } else {
        set data = ##class(%Library.File).SubDirectoryName(data, "csp")
    }

    set data = ##class(%Library.File).SubDirectoryName(data,
        $ZCONVERT($REPLACE("%SYS", "%", ""), "l")
    )
    set data = ##class(%Library.File).SubDirectoryName(data, "webterminal")
    set data = ##class(%Library.File).SubDirectoryName(data, "js")
    set data = ##class(%Library.File).SubDirectoryName(data, "autocomplete")
    set data = ##class(%Library.File).SubDirectoryName(data, namespace _ ".js")

    quit data
]]></Implementation>
</Method>

<Method name="WriteToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String,data:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set file=##class(%File).%New(filename)
    do file.Open("WSN")
    do file.WriteLine(data)
    do file.Close()
]]></Implementation>
</Method>

<Method name="getGlobalsJSON">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

    set out = "{"
    set rset=##class(%ResultSet).%New("%SYS.GlobalQuery:NameSpaceList")
    set sc=rset.Execute($ZNSPACE,"*",0)
    while (rset.Next()) {
        set out = out _ """" _ $Piece(rset.GetData(1),"(",1) _ """:0,"
    }
    set out = $EXTRACT(out,1,$LENGTH(out)-1) _ "}"

    // todo:
    // Set Rset = ##class(%Library.ResultSet).%New("%SYS.GlobalQuery:NameSpaceListChui")
    // s Status=Rset.Execute(NameSpace,Mask,SystemGlobals,.UnavailableDatabases)

    q out
]]></Implementation>
</Method>

<Method name="GenerateAutocompleteFile">
<Description>
Generates autocomplete file for namespace. Second parameter decides if
it will be regenerated again. But if namespace equals to "%" - generates
autocomplete file for system classes. Make sure that autocomplete for
system classes generates one time and forever.
@param genSystem - Shows if system classes need to be generated. </Description>
<FormalSpec>namespace:%String,genSystem:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

    if (genSystem) {
        set filename = ..GetJSAutocompleteFilePath("%")
    } else {
        set filename = ..GetJSAutocompleteFilePath(namespace)
    }

    do ..SendData("29", ..ConstClientOutputLocalized)
    do ..SendData(" " _ filename _ $C(13, 10))

    if ('##class(%SYS.Namespace).Exists(namespace)) {
        do ..SendData("30", ..ConstClientOutputLocalized)
        do ..SendData(" " _ namespace _ $C(13, 10))
        quit $$$NOTOK
    }

    if ('##class(%File).DirectoryExists(##class(%File).GetDirectory(filename))) {

        // try to create missed directory
        set result = ##class(%File).CreateDirectoryChain(##class(%File).GetDirectory(filename))

        if (result '= 1) {
            do ..SendData("31", ..ConstClientOutputLocalized)
            do ..SendData($C(13, 10))
            quit $$$OK
        }

    }

    // get all classes names
    set result = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
    do result.Execute()

    /*
    The next COULD BE IMPROVED FOR SPEED, I beleive.
    Generates compressed JSON string of type:
    {
        "class": {
            "%ClassName1": {
                "methodName": 0,
                "propertyName": 0,
                "parameterName": 0,
                ...
            },
            "ClassName2": {
                ...
            }
        },
        "global": {
            "^%g1": 0,
            "^g2": 0
        }
    }
    */

    do ..SendData($C(13, 10))
    do ..SendData("32", ..ConstClientOutputLocalized)

    set file=##class(%File).%New(filename)
    do file.Open("WSN")

    // final data generation
    do file.Write("{""class"":{")
    set first = ""
    set u = 1

    while (result.Next()) { // forming autocomplete for each class

        if (genSystem) '= ($Extract(result.Data("Name"), 1) = "%") {
            continue
        }

        set className = result.Data("Name")

        do ..SendData($C(27) _ "[30G" _ u)
        s u = u + 1

        do file.Write(first _ """" _ className _ """:{")
        if (first = "") set first = ","

        set cdefs = ##class(%Dictionary.ClassDefinition).%OpenId(className)

        set countMethods = cdefs.Methods.Count()
        set countParameters = cdefs.Parameters.Count()
        set countProperties = cdefs.Properties.Count()
        set total = countMethods + countParameters + countProperties
        set current = 0

        for i=1:1:countMethods {
            set current = current + 1
            do file.Write("""" _ cdefs.Methods.GetAt(i).Name _ """:0")
            if (current'=total) do file.Write(",")
        }

        for i=1:1:countProperties {
            set current = current + 1
            do file.Write("""" _ cdefs.Properties.GetAt(i).Name _ """:0")
            if (current'=total) do file.Write(",")
        }

        for i=1:1:countParameters {
            set current = current + 1
            do file.Write("""" _ cdefs.Parameters.GetAt(i).Name _ """:0")
            if (current'=total) do file.Write(",")
        }

        do file.Write("}")

    }

    do file.Write("}")
    if ('genSystem) do file.Write(",""global"":" _ ..getGlobalsJSON())
    do file.Write("}")
    do file.Close()

    do ..SendData($C(13, 10))
    do ..SendData("33", ..ConstClientOutputLocalized)
    do ..SendData($C(13, 10))
    //do ..SendData(namespace, ..ConstClientLoadAutocomplete)

    quit $$$OK
]]></Implementation>
</Method>

<Method name="Reset">
<Description>
Returns terminal to default state</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    // delete autocompletion files
    set dir = ##class(%File).GetDirectory(..GetJSAutocompleteFilePath("TEST"))
    if (##class(%File).DirectoryExists(dir)) {
        do ##class(%File).RemoveDirectoryTree(dir)
    }
    quit $$$OK
]]></Implementation>
</Method>

<Method name="SendData">
<Description>
Function sends data derectly to server with specified action</Description>
<FormalSpec>query:%String="",action:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    if (action = "") { set action = ..ConstClientOutputMessage }
    do ..Write(action _ query)
]]></Implementation>
</Method>

<Method name="ExecuteSQL">
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    do ..StartClearIO()
    do ##class(%Device).ReDirectIO($$$YES)

    set tStatement = ##class(%SQL.Statement).%New()
    set qStatus = tStatement.%Prepare(query)
    if qStatus'=1 {
        write $System.Status.DisplayError(qStatus)
    } else {
        set rset = tStatement.%Execute()
        do rset.%Display()
    }

    do ##class(%Device).ReDirectIO($$$NO)
    do ..EndClearIO()

    quit $$$OK
]]></Implementation>
</Method>

<Method name="ClientAlertNamespace">
<Description>
Sends to client new namespace if last was changed</Description>
<Implementation><![CDATA[
    if (..CurrentNamespace '= $Znspace) { // change client namespace
        set ..CurrentNamespace = $Znspace
        do ..SendData(..CurrentNamespace,..ConstClientChangeNamespace)
    }
]]></Implementation>
</Method>

<Method name="StartClearIO">
<Description>
Starts clear I/O mode</Description>
<Implementation><![CDATA[
    write *-3
    do ..Write(..ConstClientStartExec)
    write *-3
    do ##class(%Device).ReDirectIO($$$YES)
]]></Implementation>
</Method>

<Method name="EndClearIO">
<Description>
Ends clear I/O mode</Description>
<Implementation><![CDATA[
    //write *-3
    do ##class(%Device).ReDirectIO($$$NO)
    do ..SendData("",..ConstClientEndExec)
    write *-3
]]></Implementation>
</Method>

<Method name="ParseError">
<Description>
This method transforms error </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set string = $REPLACE($REPLACE(string, ">", "<"), ".Engine.", "<")
    quit "ERROR: " _ $PIECE(string, "<", 2) _
        $EXTRACT($PIECE(string, "<", 4), 2, *)
]]></Implementation>
</Method>

<Method name="Update">
<FormalSpec>version</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set httprequest = ##class(%Net.HttpRequest).%New()
    set httprequest.Server = "intersystems-ru.github.io"
    do ..SendData("34", ..ConstClientOutputLocalized)
    do ..SendData(" http://intersystems-ru.github.io/webterminal/files/WebTerminal-"
        _ version _ ".xml ")
    do httprequest.Get("/webterminal/files/WebTerminal-" _ version _ ".xml")
    if (httprequest.HttpResponse.StatusCode '= 200) {
        do ..SendData($C(27)_"[31mFAIL" _ $C(27) _ "[0m (status code "
            _ httprequest.HttpResponse.StatusCode _ ")" _ $C(13,10))
        quit $$$NOTOK
    }
    do ..SendData($C(27)_"[32mOK" _ $C(27) _ "[0m")
    if ($isobject(httprequest.HttpResponse.Data)) {
        do ..SendData($C(13,10))
        do ..SendData("35", ..ConstClientOutputLocalized)
        do ..SendData($C(13,10))
        do $system.OBJ.LoadStream(httprequest.HttpResponse.Data,"",.error,.items)
        if (error) {
            do ..SendData($C(27)_"[31mFAILED" _ $C(27) _ "[0m" _ $C(13,10))
            quit $$$NOTOK
        }
    }
    quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckUpdate">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set httprequest = ##class(%Net.HttpRequest).%New()
    set httprequest.Server = "intersystems-ru.github.io"
    do httprequest.Get("/webterminal/latestVersion")
    if (httprequest.HttpResponse.StatusCode '= 200) {
        do ..SendData($C(27)_"[31mFAIL" _ $C(27) _ "[0m (status code "
            _ httprequest.HttpResponse.StatusCode _ ")" _ $C(13,10))
        quit $$$NOTOK
    }
    if ($isobject(httprequest.HttpResponse.Data)) {
        do ..SendData(httprequest.HttpResponse.Data.Read(), ..ConstClientPromptUpdate)
    }
    quit $$$OK
]]></Implementation>
</Method>

<Method name="ExecuteCommand">
<Description>
The heart of terminal application</Description>
<FormalSpec>query:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    if (query = "") quit $$$OK

    #dim exception as %Exception.AbstractException
    set value = $Replace(query, $CHAR(10), " ")

    do ..StartClearIO() // execute session start

    set $ZERROR = ""

    try { xecute value } catch exception {
        set $ZERROR = exception.DisplayString()
    }

    if ($ZERROR '= "") {
        w $ZERROR, *-3
    }

    do ..EndClearIO() // execute session end
    do ..ClientAlertNamespace() // check namespace change

    quit $$$OK
]]></Implementation>
</Method>

<Method name="RequireAuthorization">
<Description>
This method holds process and expects only one package from
the client - it includes authorization key.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set authKey = ..Read(, .status, ..#authorizationTimeout) // wait for package
    set ok = $$$NOTOK

    set namespace = ""
    set pos = $FIND(authKey, "#")
    if pos '= 0 {
        set namespace = $EXTRACT(authKey, pos, *)
        set authKey = $EXTRACT(authKey, 1, pos-2)
    }

    /*
     * Find given CSPSessionCookie in WebTerminal auth global. If found, grant access.
     */
    SET key = $ORDER(^WebTerminal.AuthUser(""))
    WHILE (key '= "") {
        set lb = $GET(^WebTerminal.AuthUser(key))
        if ((lb '= "") && (key = authKey)) {

            // setup privileges
            set username = $LISTGET(lb, 1) // user name
            do ##class(Security.Users).Get(username, .userProps)
            continue:($order(userProps("")) = "")

            set namespace = $case(namespace, "":userProps("NameSpace"), :namespace)
            set loginStatus = ##class(%SYSTEM.Security).Login(username) // login user

            kill ^WebTerminal.AuthUser(key)

            set ok = loginStatus

        }

        // kill "old" auth tickets
        set time = $LISTGET(lb, 2)
        if (time '= "") && ($SYSTEM.SQL.DATEDIFF("s", time, $h) > 100) { // if older than 100 sec
            kill ^WebTerminal.AuthUser(key)
        }

        SET key = $ORDER(^WebTerminal.AuthUser(key))
    }

    if (namespace '= "") {
        try { // in case user may specify namespace that does not exists
            znspace namespace
        } catch (e) {  }
    }

    quit ok
]]></Implementation>
</Method>

<Method name="ClientLoop">
<Description>
Main method for every new client.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    kill // clear junk vars

    do ..SendData($NAMESPACE, ..ConstClientPrompt)

    for {

        set data = ..Read(,.status)

        if $$$ISERR(status) {

            try {
                do ..SendData("40", ..ConstClientOutputLocalized)
            } catch e { }
            quit:($$$GETERRORCODE(status)=$$$CSPWebSocketClosed)

        }

        set pos = $FIND(data, "#")
        set action = $EXTRACT(data, 1, pos-2)
        set data = $EXTRACT(data, pos, *)

        if (action = ..ConstServerActionExecute) {

            do ..ExecuteCommand(data)
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        } elseif (action = ..ConstServerActionCheckTrace) {

            set changes = ..CheckTracing()
            if (changes '= "") {
                do ..SendData(changes)
            }

        } elseif (action = ..ConstServerActionTrace) { // add/remove

            set result = ..Trace(data)
            if ('$$$ISOK(result)) {
                set result = ..StopTracing(data)
                if ('$$$ISOK(result)) {
                    do ..SendData("!" _ data, ..ConstClientTrace)
                }
            }
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        } elseif (action = ..ConstServerActionStopTraceAll) { // add/remove

            FOR i=1:1:$LISTLENGTH(..Watches) {
                d ..StopTracing($LIST(..Watches, i))
            }
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        } elseif (action = ..ConstServerActionExecuteSQL) { // sql

            do ..ExecuteSQL(data)
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        } elseif (action = ..ConstServerActionGenerateAutocomplete) {

            // data shows if system classes required

            if ('##class("%Library.File").Exists(..GetJSAutocompleteFilePath("%")))
                || (data = "1") {
                do ..GenerateAutocompleteFile("%SYS", 1)
                do ..SendData("%", ..ConstClientLoadAutocomplete)
            }
            do ..GenerateAutocompleteFile(..CurrentNamespace, 0)
            do ..SendData(..CurrentNamespace, ..ConstClientLoadAutocomplete)

        } elseif (action = ..ConstServerActionReset) {

            do ..Reset()
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        } elseif (action = ..ConstServerActionEcho) {

            do ..StartClearIO()
            write data
            do ..EndClearIO()
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        } elseif (action = ..ConstServerActionCheckUpdate) {

            do ..CheckUpdate()

        } elseif (action = ..ConstServerActionUpdate) {

            do ..Update(data)
            do ..SendData("39", ..ConstClientOutputLocalized)

        } else { // something scary

            do ..SendData("38", ..ConstClientOutputLocalized)
            do ..SendData(" " _ action)
            do ..SendData($NAMESPACE, ..ConstClientPrompt)

        }

    }
]]></Implementation>
</Method>

<Method name="Server">
<Description>
New connection established: require auth key, login and start client loop.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    /*UNCOMMENT ON RELEASE!*/
    if ($$$ISOK(..RequireAuthorization())) {

        set ..CurrentNamespace = $Znspace

        do ..SendData("1", ..ConstClientAuthorizationStatus)
        do ..SendData(..CurrentNamespace, ..ConstClientChangeNamespace)

        use $io:(/NOXY:/BREAK):"^" _ ..InitialZName
        do ..ClientLoop()

    } else {

        do ..SendData("0", ..ConstClientAuthorizationStatus)
        do ..EndServer()

    }

    quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%WebTerminal.Installer">
<Description>
Importing this class will install Cache WEB Terminal properly.</Description>
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>63890,71053.144208</TimeCreated>

<Parameter name="DispatchClass">
<Default>%WebTerminal.Router</Default>
</Parameter>

<Projection name="Reference">
<Type>Installer</Type>
</Projection>

<Method name="CreateProjection">
<Description>
This method is invoked when a class is compiled.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[cls:%String,&params]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set ns = $NAMESPACE
    zn:ns'="%SYS" "%SYS"
    do ##class(Security.System).GetInstallationSecuritySetting(.security)
    set cspProperties("AutheEnabled") = 32 // password by default, 64 for no password
    set cspProperties("NameSpace") = "%SYS" // terminal works only in %SYS namespace, only in % package
    set cspProperties("Description") = "A WEB application for Cache WEB Terminal."
    set cspProperties("IsNameSpaceDefault") = 0
    set cspProperties("DispatchClass") = ..#DispatchClass
    if ('##class(Security.Applications).Exists("/terminal")) {
        w !, "Creating WEB application ""/terminal""..."
        set tSC = ##class(Security.Applications).Create("/terminal", .cspProperties)
        if $$$ISERR(tSC) throw ##class(%Installer.Exception).CreateFromStatus(tSC)
        w !, "WEB application ""/terminal"" is created."
        set ^SYS("Security", "CSP", "AllowClass", "/terminal/", ..#DispatchClass) = 1
    } else {
        do ##class(Security.Applications).Get("/terminal", .props)
        if (props("DispatchClass") '= ..#DispatchClass) {
            w !, "WARNING! WEB application ""/terminal"" exists but does not refer to ",
                DispatchClass, ".", !, "Please, set correct dispatch class for this application ",
                "or create a terminal WEB-application manually."
        } else {
            w !, "WEB application ""/terminal"" already exists, so it is ready to use."
        }
    }
    zn:ns'="%SYS" ns
    quit $$$OK
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<Description>
This method is invoked when a class is 'uncompiled'.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[cls:%String,&params,recompile:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set ns = $NAMESPACE
    zn:ns'="%SYS" "%SYS"
    if (##class(Security.Applications).Exists("/terminal")) {
        do ##class(Security.Applications).Get("/terminal", .props)
        if (props("DispatchClass") '= ..#DispatchClass) {
            w !, "Won't remove WEB-application ""/terminal"" because it does not refer to ",
                "dispatch class anymore."
        } else {
            w !, "Deleting WEB application ""/terminal""..."
            do ##class(Security.Applications).Delete("/terminal")
            kill ^SYS("Security", "CSP", "AllowClass", "/terminal/", ..#DispatchClass)
            w !, "WEB application ""/terminal"" was successfully removed."
        }
    }
    zn:ns'="%SYS" ns
    QUIT $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%WebTerminal.Router">
<Description>
The REST interface: class that routes HTTP requests</Description>
<Super>%CSP.REST</Super>
<TimeCreated>63890,69646.001045</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
   <Route Url="/" Method="GET" Call="Index"/>
   <Route Url="/index" Method="GET" Call="Index"/>
   <Route Url="/css/terminal.css" Method="GET" Call="GetCss"/>
   <Route Url="/css/terminal-theme/:theme" Method="GET" Call="GetTheme"/>
   <Route Url="/js/terminal.js" Method="GET" Call="GetJs"/>
   <Route Url="/Autocomplete" Method="GET" Call="WriteAutocomplete"/>
</Routes>
]]></Data>
</XData>

<Method name="WriteAutocomplete">
<Description>
Method returns autocomplete data in JSON format</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    write "{""test"":1}"
    return $$$OK
]]></Implementation>
</Method>

<Method name="WriteStatic">
<Description>
Calls StaticContent.Write method or sends not modified header. Type have to be "css" or "js"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,Auth:%String="",ContentType:%String=""</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    #define CompileTime ##Expression("""" _ $zd($h, 11) _ ", "_ $zdt($NOW(0), 2,1) _ " GMT""")
    set %response.CharSet = "utf-8"
    set %response.ContentType = $case(type,
        "css": "text/css",
        "js": "text/javascript",
        "html": "text/html",
        : $case(ContentType="", 1:"text/plain", :ContentType)
    )
    do %response.SetHeader("Last-Modified", $$$CompileTime)

    if (%request.GetCgiEnv("HTTP_IF_MODIFIED_SINCE")=$$$CompileTime) && (Auth = "") {
        set %response.Status = "304 Not Modified"
    } else {
        do ##class(StaticContent).Write(type, Auth)
    }
]]></Implementation>
</Method>

<Method name="GetCss">
<Description>
Method writes application CSS.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    do ..WriteStatic("css")
    return $$$OK
]]></Implementation>
</Method>

<Method name="GetTheme">
<Description>
Method writes application theme.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Theme:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    do ..WriteStatic("Theme"_$REPLACE(Theme, ".css", ""),,"text/css")
    return $$$OK
]]></Implementation>
</Method>

<Method name="GetJs">
<Description>
Method writes application JavaScript.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    do ..WriteStatic("js")
    return $$$OK
]]></Implementation>
</Method>

<Method name="Index">
<Description>
Method writes application HTML.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set cookie = %session.CSPSessionCookie
    // Put the name of authorized user in a global to authorize WebSocket WebTerminal connection
    set ^WebTerminal.AuthUser(cookie) = $LB(
        $LISTGET(%session.SecurityContext, 1), // username
        $horolog // granting ticket date
    )
    do ..WriteStatic("html", cookie)
    return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%WebTerminal.StaticContent">
<Description>
This class holds whole application static content like scripts and styles.
Do not edit this file - use external tool to generate it.</Description>
<TimeCreated>63890,69938.115592</TimeCreated>

<Method name="Write">
<Description>
Write the contents of xData tag</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Const:%String,Auth:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set Auth = $get(Auth, "")
    set obj = ##class(%Dictionary.CompiledXData).%OpenId("%WebTerminal.StaticContent||"_Const)
    quit:(obj = "") $$$OK
    set xdata = obj.Data
    set status=##class(%XML.TextReader).ParseStream(xdata, .textreader)
    while textreader.Read() { if (textreader.NodeType="chars") {
        if (Auth '= "") {// authorization key injection
            write $REPLACE(textreader.Value, "createTerminal()", "createTerminal('"_Auth_"','"_%request.Get("NS")_"')")
        } else {
            write textreader.Value
        }
    } }
    quit $$$OK
]]></Implementation>
</Method>
{{replace:themes}}
<XData name="Theme{{replace:themeName}}">
<Data><![CDATA[
<data>
<![CDATA[{{replace:themeData}}]]]]><![CDATA[>
</data>
]]></Data>
</XData>
{{replace:end}}
<XData name="html">
<Data><![CDATA[
<data>
<![CDATA[{{replace:html}}]]]]><![CDATA[>
</data>
]]></Data>
</XData>

<XData name="css">
<Data><![CDATA[
<data>
<![CDATA[{{replace:css}}]]]]><![CDATA[>
</data>
]]></Data>
</XData>

<XData name="js">
<Data><![CDATA[
<data>
<![CDATA[{{replace:js}}]]]]><![CDATA[>
</data>
]]></Data>
</XData>
</Class>


<Project name="WEBTerminal" LastModified="2015-12-06 12:10:07.906721">
  <Items>
    <ProjectItem name="%WebTerminal.Engine" type="CLS"></ProjectItem>
    <ProjectItem name="%WebTerminal.Installer" type="CLS"></ProjectItem>
    <ProjectItem name="%WebTerminal.Router" type="CLS"></ProjectItem>
    <ProjectItem name="%WebTerminal.StaticContent" type="CLS"></ProjectItem>
  </Items>
</Project>
</Export>
